

```markdown
## Phase 1: Core Infrastructure & Architecture

**Objective:** Bootstrap the Next.js 15 App Router project with Supabase SSR authentication, React Compiler, and a dark-mode UI shell.

### The Architect Prompt
**Tool:** Cursor
**Target:** Empty project directory

> Act as a Senior Next.js Architect. Initialize the 'RelantoPulse' project strictly as a Next.js 15 Application with React Compiler.
> 
> CRITICAL ARCHITECTURE RULES:
> - Framework: Next.js 15 (App Router). Do NOT use Vite.
> - Compiler: Enable the React Compiler (experimental/beta) in next.config.mjs for automatic memoization.
> - Structure: You MUST use the src/app directory structure.
> - Config: Generate next.config.mjs.
> - Environment: Use NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY.
> 
> 1. Core Infrastructure (The Skeleton):
> - Install Dependencies: next@latest, react@latest, react-dom@latest,          babel-plugin-react-compiler, @supabase/ssr, @supabase/supabase-js, lucide-react, clsx, tailwind-merge.
> - Next Config: Enable experimental { reactCompiler: true }.
> - Supabase Client: Create a browser client using createBrowserClient.
> - Supabase Server: Create a server client using createServerClient (handling cookies).
> - Middleware: Matcher ['/dashboard/:path*', '/login', '/auth/:path*']. Refresh session. Redirect unauthenticated users to /login. Redirect logged-in users from /login to /dashboard.
> 
> 2. UI Deliverables (The Visuals):
> - Root Layout: Apply Inter font globally. bg-slate-900 (Dark theme default). text-white.
> - Landing Page: A modern Hero Section. Headline: "RELANTO PULSE - A PROGRESS TRACKING PLATFORM". Subtext: "The all-in-one workspace for Digital Trainees." Actions: Login (Primary), Sign Up (Secondary).
> - Login Page: 'use client' component. Form with Email/Password. Action: Call supabase.auth.signInWithPassword. Handle loading/errors state.
> - Dashboard Shell: Protected server component. Check for session. Display: "Welcome, [User Email]". Action: <SignOutButton /> component.
> 
> 3. Execution:
> Ensure strict TypeScript safety. Output the complete file structure.

### üõ†Ô∏è Manual Actions Required After Generation
1. **Set Environment Variables:** Create a `.env.local` file in the root directory and populate it with your Supabase keys.
   ```env
   NEXT_PUBLIC_SUPABASE_URL=your_url_here
   NEXT_PUBLIC_SUPABASE_ANON_KEY=your_key_here

```

2. **Enable Email Auth:** Go to the Supabase Dashboard -> Authentication -> Providers, and ensure **Email** is enabled. Disable "Confirm email" for easier local testing.

---

## Phase 2: Dashboard Core & Database Schema

**Objective:** Set up the PostgreSQL tables for user profiles and goals, implement Row Level Security (RLS), and build the main Dashboard UI widgets.

### The Dashboard Prompt

**Tool:** Cursor / GitHub Copilot
**Target:** Phase 1 codebase

> Act as a Senior Next.js 15 Architect. We are building Phase 2 of 'RelantoPulse': The Dashboard Core.
> Goal: Create the Database Schema, Server Actions, and UI for the main Dashboard view.
> Context:
> * App Type: Internship Tracker & Daily Planner.
> * Timeline: Feb 2, 2026 ‚Äì June 30, 2026.
> * Tech Stack: Next.js 15 (App Router), Supabase (Auth + DB), Tailwind CSS, Lucide React.
> * Date Library: Use date-fns for all date logic.

> 1. Database Schema (Supabase SQL):
> Create a SQL migration script.

 * Table profiles: id (uuid, PK, references auth.users), email (text), full_name (text), role (text, default 'Intern'). Trigger: Auto-create profile on signup.
>* Table goals: id (uuid, PK), user_id (uuid, references auth.users), title     (text, not null), status (text, check constraint: 'pending' | 'in_progress' | 'completed', default 'pending'), target_date (date, not null), created_at (timestamptz).
> * RLS Policies: Enable RLS on both tables. Users can strictly Select/Insert/Update/Delete their own data only.
> 

> 2. Server Actions (src/lib/actions/dashboard.ts):
> * getDashboardStats(): Calculates Internship Progress %. Fetches Backlog Count. Fetches User Profile.
> * getTodayGoals(): Returns all goals where target_date == TODAY.
> * toggleGoalStatus(goalId, newStatus): Updates a goal's status.


> 3. UI Components:
> * src/components/dashboard/sidebar.tsx: Fixed left sidebar (w-64). Links: Dashboard, Roadmap, Planner, AI Quiz, Settings. User Widget at bottom.
> * src/app/dashboard/layout.tsx: Integrate Sidebar. Mobile responsiveness.
> * src/app/dashboard/page.tsx: Header with current date. 2 Grid Cards (Progress Bar, Backlog Banner). Today's Focus Section with toggleable goals.


> Execution Steps:
> Provide the SQL script first. Install necessary packages. Generate Server Actions. Generate Layout and Page components.

### üõ†Ô∏è Manual Actions Required After Generation

1. **Execute SQL Migration:** Copy the raw SQL generated by the AI (specifically for the `profiles` table, `goals` table, and the auto-profile trigger) and paste it into the **Supabase SQL Editor**. Click **Run**.
2. **Install Date Library:** Ensure the date manipulation library was installed correctly.
```bash
npm install date-fns

```



```

```

```markdown
## Phase 3: The Planner & Roadmap Engines

**Objective:** Build the Planner (Day View) and Roadmap (Week View) pages with File Upload and Journal capabilities to track daily intern activities.

### The Planner & Roadmap Prompt
**Tool:** Cursor / GitHub Copilot
**Target:** src/app/planner and src/app/roadmap directories

> Act as a Senior Full Stack Engineer. Phase 3: The Planner & Roadmap Engines.
> Goal: Build the Planner (Day View) and Roadmap (Week View) pages with File Upload and Journal capabilities.
> 
> 1. Database Schema Updates (Supabase SQL):
> - New Table journals: id (uuid, PK), user_id (fk), entry_date (date, unique per user), content (text), created_at.
> - New Table attachments: id (uuid, PK), user_id (fk), entry_date (date), file_name (text), file_path (text), file_type (text), file_size (int).
> - New Table weeks: id (uuid, PK), week_number (int), title (text), phase (text: 'Virtual' or 'In-Office'), start_date (date), end_date (date). Seed Data: Insert 20 rows. Weeks 1-4 = 'Virtual', Weeks 5-20 = 'In-Office'. Use generic titles like "Sprint 1", "Sprint 2" for now.
> - Storage Policies: Generate SQL to allow Authenticated users to Upload/Select/Delete from the attachments bucket.
> 
> 2. The Planner Page (src/app/planner/page.tsx):
> - Layout: Two-column layout (Left: Goals, Right: Journal).
> - Date Navigation: Top bar with "Previous | [Selected Date] | Next" and a Calendar Picker to jump to any date.
> - Left Column (Goals): Re-use the logic from Dashboard but for the selected date. Allow adding unlimited goals with custom titles. Edit/Delete goals.
> - Right Column (Journal & Files): Journal Editor: A simple Textarea that auto-saves to the journals table for that date. File Upload Section: "Upload Resources" button (triggers file picker). Upon selection, upload to Supabase Storage -> Save record to attachments table. List View: Display uploaded files below the button as downloadable links (with a trash icon to delete).
> 
> 3. The Roadmap Page (src/app/roadmap/page.tsx):
> - Visual: Accordion-style list of weeks (Weeks 1-20).
> - Phase Logic: Weeks 1-4 (Virtual): Blue/Indigo theme borders/badges. Weeks 5+ (In-Office): Emerald/Green theme borders/badges.
> - Accordion Item (Closed): Shows "Week X", Phase Badge, and an Editable Title Input (User can rename "Week 1" to "Onboarding Week").
> - Accordion Item (Expanded): Shows a list of days (Mon-Fri) for that week. For each day, show a summary of goals (e.g., "3 Goals Completed" or a simple list). Note: Read-only view. No editing goals here.
> - Data Source: Fetch weeks table for structure. For the expanded content, join with goals table based on the week's date range.
> 
> 4. Server Actions (src/lib/actions/planner.ts & roadmap.ts):
> - getPlannerData(date): Returns goals, journal entry, and attachments.
> - saveJournal(date, content): Upsert function.
> - uploadAttachment(formData): Handle storage upload + db insert.
> - deleteAttachment(id, path): Handle storage delete + db delete.
> - updateWeekTitle(weekId, newTitle): Update the weeks table.
> Design: Use shadcn/ui (Accordion, Calendar, Dialog, Textarea). Keep the styling consistent with the dark theme Dashboard.

### üõ†Ô∏è Manual Actions Required After Generation
1. **Execute SQL Migration:** Run the newly generated SQL script in the Supabase Dashboard to create the `journals`, `attachments`, and `weeks` tables.
2. **Create Storage Bucket:** Go to Supabase Storage and manually create a bucket named `attachments`. Set it to **Public** (or configure the exact RLS policies generated by the AI to secure it).
3. **Install UI Components:** The AI was instructed to use `shadcn/ui`. You must initialize it and add the requested components:
   ```bash
   npx shadcn@latest init
   npx shadcn@latest add accordion calendar dialog textarea

```

---

## Phase 4: The AI Interview Simulator

**Objective:** Build an interactive "Mock Interview" engine using the Google Gemini API to test interns on their completed goals or custom topics.

### The AI Quiz Prompt

**Tool:** Cursor / GitHub Copilot
**Target:** src/app/quiz/page.tsx and src/lib/actions/quiz.ts

> Act as a Senior AI Engineer & Next.js Architect. Phase 4: The AI Interview Simulator.
> Goal: Build src/app/quiz/page.tsx as an interactive "Mock Interview" engine with two distinct modes: "Custom Topic" and "Surprise Challenge".
> 1. Server Actions (src/lib/actions/quiz.ts):
> * getRandomGoalTopic(excludeTopic?: string): Logic: Query the goals table for status = 'completed'. Constraint: If excludeTopic is provided, filter it out (title != excludeTopic). Sort: Order by Random (Postgres: RANDOM()). Limit 1. Fallback: If no goals are found, return a default generic topic like "Software Engineering Professionalism" or "Agile Methodology".
> * generateInterviewQuestion(topic): Input: A string (topic). API: Call Google Gemini (google-generative-ai). System Prompt: "You are a Senior Technical Interviewer. Context: The candidate (intern) has worked on: '${topic}'. Task: Generate 1 challenging, scenario-based multiple-choice question. Rules: If technical, ask about architecture/edge cases. If non-technical, ask about soft skills/conflict resolution. Output: JSON only. { question, options[], correctAnswerIndex, explanation }."
> 
> 
> 2. The UI (src/app/quiz/page.tsx):
> * Header: "AI Mock Interviewer".
> * Mode Selection (Two distinct sections/cards): Card A: "Targeted Practice" (Input Field: "Enter a topic", Button: "Ask Me Anything" triggers generateInterviewQuestion). Card B: "Review My Work" (Text: "Test your knowledge on your completed tasks.", Button: "Surprise Me üé≤" triggers getRandomGoalTopic -> then generateInterviewQuestion).
> * The Quiz Interface (Replaces the selection cards when active): Top Bar: "Topic: [Topic Name]" | "Score: [X]". Question Card: Large text. Options: 4 interactive buttons. Feedback: Reveal explanation after selection. "Next Challenge" Button: If in "Surprise Mode": Calls getRandomGoalTopic again. If in "Targeted Mode": Resets to input screen.
> 
> 
> 3. Implementation Details:
> * Use framer-motion for smooth transitions between Question and Result.
> * Use zod for JSON validation.
> * Error Handling: If Gemini fails or DB is empty, show a toast notification.

### üõ†Ô∏è Manual Actions Required After Generation

1. **Install Dependencies:** The prompt explicitly asks for Framer Motion and Zod. Install them to prevent build errors.
```bash
npm install framer-motion zod

```
2. **Verify Gemini API Key:** Ensure your `GEMINI_API_KEY` is present in your `.env.local` file, and that your `src/lib/gemini.ts` client is successfully reading it to authenticate the `google-generative-ai` SDK.

Here is the exact Markdown block containing the final phases of your build guide. I have formatted your prompts perfectly and included the critical manual actions for each step, along with the requested protocol for AI debugging.

Click "Copy code" and paste this directly beneath your Phase 4 section to complete your `BUILD_GUIDE.md` file.

```markdown
## Phase 5: Google OAuth Integration

**Objective:** Implement seamless Single Sign-On (SSO) for users using Google credentials alongside standard email authentication.

### The OAuth Prompt
**Tool:** Cursor / GitHub Copilot
**Target:** src/components and src/app/auth/callback

> I have configured Google OAuth in my Supabase dashboard. I need to implement the frontend button and backend callback in my Next.js App Router project. Please generate or update the following files:
>
> First, create a client component at src/components/GoogleSignInButton.tsx. Use @/lib/supabase/client to call supabase.auth.signInWithOAuth. Pass the provider as 'google' and set the redirectTo option to dynamically use window.location.origin followed by /auth/callback. Style it cleanly with Tailwind CSS and an SVG Google logo to match a standard auth button.
>
> Second, update my existing login page to include the new GoogleSignInButton component just below the standard email and password form.
>
> Third, create a route handler at src/app/auth/callback/route.ts. It must intercept the GET request, extract the 'code' from the URL search parameters, and use @/lib/supabase/server to call supabase.auth.exchangeCodeForSession(code). If the exchange is successful, redirect the user to /dashboard. If it fails, redirect the user back to /login with an error parameter in the URL.
>
> CRITICAL INSTRUCTION: You must strictly remove all comments from the generated code snippets. Do not include a single slash or block comment inside the TypeScript or TSX code.

### üõ†Ô∏è Manual Actions Required After Generation
1. **Google Cloud Console Setup:** You must manually create OAuth 2.0 Client IDs in the Google Cloud Console.
2. **Supabase Provider Configuration:** Paste your Google Client ID and Secret into the Supabase Dashboard under **Authentication > Providers > Google**.
3. **Set Redirect URIs:** Ensure your Vercel URL and `http://localhost:3000/auth/callback` are added to the allowed redirect URIs in both Google Cloud and Supabase.

---

## Phase 6: Strict Authentication Validation

**Objective:** Improve UX by trapping edge-case errors during standard Email/Password authentication.

### The Auth Validation Prompt
**Tool:** Cursor / GitHub Copilot
**Target:** Login and Signup form components

> I need to enforce strict validation for my standard Email and Password authentication flows only.
>
> CRITICAL RULE 1: Do NOT change, touch, or modify anything about the Google Auth flow. Leave the GoogleSignInButton component and the OAuth callback route exactly as they are.
>
> Update my signup and login form submit handlers with the following logic:
> For the Sign Up form (Email/Password): When calling supabase.auth.signUp(), check the error response. If the error message indicates the user already exists, display a clear UI message or toast saying "Account already created. Please log in."
>
> For the Login form (Email/Password): When calling supabase.auth.signInWithPassword(), check the error response. If the error indicates invalid credentials or the user does not exist, display a clear UI message or toast saying "Account not found. Please sign up."
>
> CRITICAL RULE 2: You must strictly remove all comments from the generated code snippets. Do not include a single slash or block comment inside the TypeScript or TSX code.

### üõ†Ô∏è Manual Actions Required After Generation
1. **Test Edge Cases:** Manually attempt to sign up with an email that already exists to verify the toast notification fires correctly instead of crashing the app.

---

## Phase 7: Admin Dashboard & Route Isolation

**Objective:** Build a secure, data-rich command center for managers using a strict environment variable whitelist.

### The Route Isolation Prompt
**Tool:** Cursor / GitHub Copilot
**Target:** src/app/admin/page.tsx, src/app/dashboard/layout.tsx, and Auth routing

> I want to implement a demo Admin Dashboard using an email whitelist, along with strict route isolation between admins and interns. I have added ADMIN_EMAILS="email1@test.com,email2@test.com" to my .env.local file.
>
> Please implement the following three things:
>
> Update the login routing logic (src/app/auth/callback/route.ts and my standard email/password login handler). After successful authentication, check if the user's email exists in the comma-separated process.env.ADMIN_EMAILS string. If the email is in the whitelist, redirect to /admin. If not, redirect to /dashboard.
>
> Create a new server component at src/app/admin/page.tsx. This page must: Verify the user session and check if their email is in the ADMIN_EMAILS whitelist. If they are NOT in the whitelist, instantly redirect('/dashboard'). Fetch all users from the profiles table whose emails are NOT in the whitelist (the interns). Fetch the associated tasks/goals for these interns to calculate "Total Goals Set" and "Total Goals Completed" for each person. Use my existing database schema conventions. Render a clean, simple Tailwind CSS table displaying: Name, Email, Total Goals Set, and Total Goals Completed.
>
> Update my intern dashboard (src/app/dashboard/layout.tsx or src/app/dashboard/page.tsx). Add a server-side check: if the logged-in user's email IS in the whitelist, instantly redirect('/admin'). Admins must be completely blocked from rendering the intern dashboard or its sub-routes.
>
> CRITICAL INSTRUCTION: You must strictly remove all comments from the generated code snippets. Do not include a single slash or block comment inside the TypeScript or TSX code.

### üõ†Ô∏è Manual Actions Required After Generation
1. **Update Environment Variables:** Add the `ADMIN_EMAILS` variable to your local `.env.local` file and your Vercel deployment settings.
   ```env
   ADMIN_EMAILS=manager@relanto.com,admin@relanto.com

```

---

## Phase 8: Intern Profile Management

**Objective:** Allow interns to update their professional details and track their assigned technology stacks.

### The Profile Page Prompt

**Tool:** Cursor / GitHub Copilot
**Target:** src/app/profile/page.tsx and Sidebar component

> I need to build a "Profile" page and update my navigation for an intern training tracker application using Next.js App Router, Tailwind CSS, and Supabase server actions.
> Please review my open files and provide the code for these two steps:
> Step 1: Update the Sidebar Navigation
> Locate my sidebar component. Find the navigation item currently labeled "Settings". Rename the display text to "Profile", update its route to point to /profile, and replace its current icon with a suitable user profile icon.
> Step 2: Generate the Profile Page UI and Logic
> Generate a professional, clean form UI for the profile page with the following requirements:
> Read-Only Email: A disabled input field showing the user's email.
> Standard Text Inputs: Full Name, Reporting Manager, GitHub Profile URL, and LinkedIn Profile URL.
> Dropdown Menus (Select):
> * Department (Options: "Digital Engineering", "Data & AI", "Cloud Infrastructure", "Product Design")
> * Role (Options: "Digital Trainee Intern", "Software Engineering Intern", "Data Intern")
> * Tech Stack (Options: "Java / Spring Boot", "Next.js / React", "Python / AI", "Data Engineering")
> 
> 
> Form Action: The form should submit data using a Next.js Server Action to update the user's record in the Supabase profiles table. Include the server action code. UI/UX: Use Tailwind CSS to make it look like a clean, modern SaaS settings page. Include a "Save Profile" submit button with a loading state.
> CRITICAL INSTRUCTION: You must strictly remove all comments from the generated code snippets. Do not include a single slash or block comment inside the TypeScript, TSX, or SQL code.

### üõ†Ô∏è Manual Actions Required After Generation

1. **Database Schema Update:** You must manually alter your Supabase `profiles` table to accept the new fields requested in the prompt.
```sql
ALTER TABLE profiles 
ADD COLUMN reporting_manager TEXT,
ADD COLUMN github_url TEXT,
ADD COLUMN linkedin_url TEXT;

```



---

## Phase 9: Role-Based Theme Toggle

**Objective:** Implement personalized workspace styling for interns while maintaining a strict, uniform view for administrators.

### The Dark Mode Prompt

**Tool:** Cursor / GitHub Copilot
**Target:** src/components/Sidebar.tsx and src/components/ThemeToggle.tsx

> I need to add a Dark/Light mode toggle to my Next.js sidebar component using next-themes and Tailwind CSS. The default theme for the application is dark.
> Please modify my existing sidebar component with the following requirements:
> Placement: In the top header section of the sidebar where the text "Relanto Pulse" is displayed, add the theme toggle button slightly to the right of the text. Use standard Tailwind Flexbox classes so they sit on the same line.
> Role-Based Rendering: The sidebar receives or fetches the current user's data. Conditionally render the theme toggle button ONLY if the user is an intern. If the user is an admin, the toggle must not appear.
> Toggle Component: Generate the code for the toggle button using next-themes useTheme hook and lucide-react icons (Sun and Moon). The button should smoothly swap icons when clicked.
> Integration: Provide the updated Sidebar code and the ThemeToggle component code. Assume next-themes is already wrapping my layout.tsx.
> CRITICAL INSTRUCTION: You must strictly remove all comments from the generated code snippets. Do not include a single slash or block comment inside the TypeScript or TSX code. Return only the raw, functional code.

### üõ†Ô∏è Manual Actions Required After Generation

1. **ThemeProvider Wrap:** Ensure your `src/app/layout.tsx` is successfully wrapped with the `ThemeProvider` component from `next-themes`, and that `attribute="class"` is set.

---

## üõë General Debugging Protocol

When building complex architectures like RelantoPulse with AI assistants, generated code will occasionally fail due to hallucinated imports, mismatched library versions, or strict TypeScript compiler errors.

**If a build error occurs:**

1. Do not attempt to rewrite the component manually.
2. Copy the exact terminal error output or the Next.js overlay error.
3. Paste the error directly back into Cursor or GitHub Copilot Chat alongside the affected file.
4. **Prompt:** *"I received this error when running the code you provided. Fix the implementation to resolve this strict type/import issue."* 5. The AI will cross-reference its previous output and generate the corrected, functional patch.

```

```